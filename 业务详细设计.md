# TradingAgents-CN 业务详细设计

> **文档版本**: v1.0
> **项目版本**: v1.0.0-preview
> **编制日期**: 2026-02-11

---

## 1. 系统架构设计

### 1.1 整体架构

系统采用分层架构，共分为六层：

```
┌─────────────────────────────────────────────────────────────────┐
│                        表现层 (Presentation)                     │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐          │
│  │  Vue 3 Web   │  │  CLI 命令行   │  │  REST API    │          │
│  └──────────────┘  └──────────────┘  └──────────────┘          │
├─────────────────────────────────────────────────────────────────┤
│                        接口层 (API Gateway)                      │
│  FastAPI + 路由分发 + 认证中间件 + 速率限制 + 错误处理            │
├─────────────────────────────────────────────────────────────────┤
│                        服务层 (Business Service)                 │
│  分析服务 | 队列服务 | 同步服务 | 报告服务 | 认证服务             │
├─────────────────────────────────────────────────────────────────┤
│                        核心层 (Core Engine)                      │
│  LangGraph 工作流编排 + 多智能体协作 + 信号处理                   │
├─────────────────────────────────────────────────────────────────┤
│                        数据层 (Data Pipeline)                    │
│  统一数据接口 + 多源适配 + 多级缓存 + 数据转换                    │
├─────────────────────────────────────────────────────────────────┤
│                        基础设施层 (Infrastructure)                │
│  MongoDB + Redis + LLM API + 数据源 API + Docker                │
└─────────────────────────────────────────────────────────────────┘
```

### 1.2 部署架构

```
┌──────────────────────────────────────────────────────────────┐
│                    Docker Compose 编排                        │
│                                                              │
│  ┌─────────────┐  ┌─────────────┐                           │
│  │  Frontend    │  │  Backend    │                           │
│  │  (Nginx)     │──│  (Uvicorn)  │                           │
│  │  Port:3000   │  │  Port:8000  │                           │
│  └─────────────┘  └──────┬──────┘                           │
│                          │                                   │
│            ┌─────────────┼─────────────┐                    │
│            │             │             │                     │
│  ┌─────────┴───┐  ┌─────┴─────┐  ┌───┴────────────┐       │
│  │  MongoDB    │  │  Redis    │  │ 外部 API 服务   │       │
│  │  Port:27017 │  │  Port:6379│  │ (LLM/数据源)    │       │
│  └─────────────┘  └───────────┘  └────────────────┘        │
└──────────────────────────────────────────────────────────────┘
```

---

## 2. 核心模块详细设计

### 2.1 多智能体系统设计

#### 2.1.1 智能体状态模型

智能体间通过共享状态 (`AgentState`) 传递信息：

```python
class AgentState(TypedDict):
    # 股票基本信息
    ticker: str                    # 股票代码
    company_name: str              # 公司名称
    market_type: str               # 市场类型 (A股/港股/美股)

    # 分析师报告
    market_report: str             # 市场分析报告
    fundamentals_report: str       # 基本面分析报告
    news_report: str               # 新闻分析报告
    sentiment_report: str          # 情绪分析报告

    # 研究报告
    bull_report: str               # 看涨研究报告
    bear_report: str               # 看跌研究报告
    investment_plan: str           # 投资计划

    # 风险管理
    risk_debate_history: list      # 风险辩论历史
    risk_assessment: str           # 风险评估结果

    # 最终决策
    final_decision: str            # 最终投资决策

    # 控制参数
    debate_count: int              # 当前辩论轮数
    risk_discuss_count: int        # 当前风险讨论轮数
```

#### 2.1.2 分析师智能体设计

每个分析师智能体遵循统一的处理模式：

```
输入: AgentState (ticker, company_name, market_type)
  ↓
1. 调用数据接口获取领域数据
  ↓
2. 构造 LLM Prompt（包含数据和分析指令）
  ↓
3. 调用 LLM 生成分析报告
  ↓
4. 将报告写入 AgentState 对应字段
  ↓
输出: 更新后的 AgentState
```

**市场分析师** (`market_analyst.py`):
- 数据来源：`get_market_data(ticker, depth)`
- 分析维度：价格趋势、成交量变化、技术指标（MA/RSI/MACD/布林带等）
- 输出字段：`market_report`

**基本面分析师** (`fundamentals_analyst.py`):
- 数据来源：`get_fundamentals_data(ticker, depth)`
- 分析维度：估值指标（P/E/P/B）、盈利能力（ROE/ROA）、成长性、现金流
- 输出字段：`fundamentals_report`

**新闻分析师** (`news_analyst.py`):
- 数据来源：`get_news_data(ticker, days, depth)`
- 分析维度：新闻情感倾向、事件影响评估、利好/利空判定
- 输出字段：`news_report`

**社交媒体分析师** (`social_media_analyst.py`):
- 数据来源：`get_sentiment_data(ticker, depth)`
- 分析维度：市场情绪指数、讨论热度、散户/机构情绪差异
- 输出字段：`sentiment_report`

#### 2.1.3 研究员智能体设计

**看涨研究员** (`bull_researcher.py`):
- 输入：四份分析师报告
- 立场：从乐观角度论证投资价值
- 方法：寻找支撑上涨的证据和逻辑
- 输出：`bull_report`

**看跌研究员** (`bear_researcher.py`):
- 输入：四份分析师报告
- 立场：从悲观角度揭示潜在风险
- 方法：寻找可能下跌的证据和逻辑
- 输出：`bear_report`

#### 2.1.4 风险管理智能体设计

三个风险管理智能体以辩论方式讨论：

```
      ┌─────────────────────────┐
      │    Investment Plan       │
      │    (投资计划输入)         │
      └────────────┬────────────┘
                   ↓
    ┌──────────────────────────────┐
    │       辩论轮次 (N轮)         │
    │                              │
    │  保守派 ──→ 中立派 ──→ 激进派 │
    │    ↑                    │    │
    │    └────────────────────┘    │
    └──────────────┬───────────────┘
                   ↓
      ┌────────────────────────────┐
      │   Risk Assessment          │
      │   (风险评估汇总)            │
      └────────────────────────────┘
```

- **保守派** (`conservative_debator.py`)：强调资本保全、规避风险
- **中立派** (`neutral_debator.py`)：平衡收益与风险
- **激进派** (`aggressive_debator.py`)：追求高收益、容忍高波动

#### 2.1.5 交易员智能体设计

**交易员** (`trader.py`):
- 输入：全部分析报告 + 研究报告 + 风险评估
- 职责：综合所有信息做出最终交易决策
- 输出格式：
  - 操作建议：买入 / 持有 / 卖出
  - 置信度：0-100%
  - 目标价位（如适用）
  - 止损价位（如适用）
  - 详细理由分析

### 2.2 工作流编排设计

#### 2.2.1 LangGraph 图结构

```python
# 节点定义
nodes = {
    "market_analyst": market_analyst_node,
    "fundamentals_analyst": fundamentals_analyst_node,
    "news_analyst": news_analyst_node,
    "social_media_analyst": social_media_analyst_node,
    "bull_researcher": bull_researcher_node,
    "bear_researcher": bear_researcher_node,
    "investment_plan": investment_plan_node,
    "conservative_debator": conservative_debator_node,
    "neutral_debator": neutral_debator_node,
    "aggressive_debator": aggressive_debator_node,
    "risk_manager": risk_manager_node,
    "trader": trader_node,
}

# 边定义（简化表示）
edges = [
    # 阶段1：并行分析
    (START, ["market_analyst", "fundamentals_analyst",
             "news_analyst", "social_media_analyst"]),

    # 阶段2：并行研究
    (analysts_done, ["bull_researcher", "bear_researcher"]),

    # 阶段3：投资计划
    (researchers_done, "investment_plan"),

    # 阶段4：风险辩论（条件循环）
    ("investment_plan", "conservative_debator"),
    ("conservative_debator", "neutral_debator"),
    ("neutral_debator", "aggressive_debator"),
    ("aggressive_debator", should_continue_debate),  # 条件判断

    # 阶段5：风险汇总
    (debate_done, "risk_manager"),

    # 阶段6：最终决策
    ("risk_manager", "trader"),
    ("trader", END),
]
```

#### 2.2.2 条件分支逻辑

```python
def should_continue_debate(state: AgentState) -> str:
    """判断是否继续辩论"""
    if state["debate_count"] < config["max_debate_rounds"]:
        return "conservative_debator"  # 继续下一轮
    else:
        return "risk_manager"          # 进入风险汇总

def should_continue_risk_discuss(state: AgentState) -> str:
    """判断是否继续风险讨论"""
    if state["risk_discuss_count"] < config["max_risk_discuss_rounds"]:
        return "continue_discuss"
    else:
        return "trader"
```

#### 2.2.3 执行阶段划分

| 阶段 | 名称 | 并行度 | 描述 |
|------|------|--------|------|
| Phase 1 | 数据分析 | 4路并行 | 四个分析师同时采集数据并分析 |
| Phase 2 | 辩证研究 | 2路并行 | 看涨/看跌研究员同时工作 |
| Phase 3 | 投资计划 | 串行 | 综合生成初步投资计划 |
| Phase 4 | 风险辩论 | 串行循环 | 三派轮流辩论，可多轮 |
| Phase 5 | 风险汇总 | 串行 | 风险经理汇总辩论结论 |
| Phase 6 | 最终决策 | 串行 | 交易员输出投资建议 |

### 2.3 数据管道详细设计

#### 2.3.1 统一数据接口 (`interface.py`)

```python
class DataInterface:
    """统一数据接口 - 门面模式"""

    def __init__(self, config: dict):
        self.source_manager = DataSourceManager(config)
        self.cache = IntegratedCache(config)

    def get_market_data(self, ticker: str, depth: str = "1y") -> dict:
        """获取市场数据（行情、技术指标）"""
        # 1. 检查缓存
        # 2. 识别市场类型
        # 3. 选择数据提供商
        # 4. 获取原始数据
        # 5. 计算技术指标
        # 6. 更新缓存
        # 7. 返回结构化数据

    def get_fundamentals_data(self, ticker: str, depth: str = "3y") -> dict:
        """获取基本面数据（财务指标）"""

    def get_news_data(self, ticker: str, days: int = 7, depth: str = "basic") -> dict:
        """获取新闻数据"""

    def get_sentiment_data(self, ticker: str, depth: str = "basic") -> dict:
        """获取情绪数据"""
```

#### 2.3.2 数据源管理器 (`data_source_manager.py`)

```python
class DataSourceManager:
    """数据源管理器 - 策略模式 + 自动降级"""

    def __init__(self, config: dict):
        self.providers = {
            "china": [TushareProvider, AKShareProvider, BaoStockProvider],
            "hk": [AKShareHKProvider, YFinanceProvider, FinnHubProvider],
            "us": [YFinanceProvider, FinnHubProvider, AlphaVantageProvider],
        }

    def get_data(self, ticker: str, data_type: str) -> dict:
        """按优先级获取数据，自动降级"""
        market = self._detect_market(ticker)
        providers = self.providers[market]

        for provider_cls in providers:
            try:
                provider = provider_cls()
                return provider.fetch(ticker, data_type)
            except Exception as e:
                logger.warning(f"{provider_cls.__name__} 失败: {e}")
                continue

        raise DataSourceError("所有数据源均不可用")

    def _detect_market(self, ticker: str) -> str:
        """识别股票所属市场"""
        # 6位纯数字 → A股
        # .HK 后缀 → 港股
        # 字母代码 → 美股
```

#### 2.3.3 缓存系统设计

```
请求数据
  ↓
┌──────────────────────────────────┐
│ L1: Redis 缓存（热数据）         │
│ TTL: 行情5分钟 / 财务1天         │
│ 命中? → 直接返回                 │
├──────────────────────────────────┤
│ L2: MongoDB 缓存（持久化）       │
│ TTL: 可配置                      │
│ 命中? → 回填 Redis → 返回        │
├──────────────────────────────────┤
│ L3: 文件缓存（兜底）             │
│ 路径: ./cache/{ticker}/{type}    │
│ 命中? → 回填 Redis+Mongo → 返回  │
├──────────────────────────────────┤
│ 缓存未命中 → 调用数据源API       │
│ 获取成功 → 写入三级缓存 → 返回   │
└──────────────────────────────────┘
```

### 2.4 LLM 适配器设计

#### 2.4.1 适配器接口

```python
class OpenAICompatibleBase:
    """OpenAI 兼容协议基类"""

    def __init__(self, api_key: str, base_url: str, model: str):
        self.client = ChatOpenAI(
            api_key=api_key,
            base_url=base_url,
            model=model,
        )

    def invoke(self, messages: list) -> str:
        """调用LLM推理"""

    def bind_tools(self, tools: list):
        """绑定工具调用能力"""
```

#### 2.4.2 适配器实现

| 适配器 | Base URL | 特殊处理 |
|--------|----------|---------|
| `DeepSeekAdapter` | `https://api.deepseek.com` | 支持 V3 模型参数 |
| `DashScopeAdapter` | `https://dashscope.aliyuncs.com/compatible-mode` | 阿里百炼兼容 |
| `GoogleAdapter` | Google AI API | Gemini 工具调用格式转换 |
| `OpenAICompatibleBase` | 自定义 | 通用 OpenAI 兼容 |

### 2.5 Web 后端服务设计

#### 2.5.1 API 路由设计

```
/api
├── /auth                     # 认证模块
│   ├── POST /register        # 用户注册
│   ├── POST /login           # 用户登录
│   └── GET /me               # 获取当前用户
│
├── /analysis                 # 分析模块
│   ├── POST /single          # 单股分析
│   ├── POST /batch           # 批量分析
│   ├── GET /history          # 历史记录
│   ├── GET /{id}             # 分析详情
│   └── DELETE /{id}          # 删除分析
│
├── /stocks                   # 股票模块
│   ├── GET /search           # 搜索股票
│   ├── GET /{code}           # 股票详情
│   └── GET /market/{type}    # 市场列表
│
├── /config                   # 配置模块
│   ├── GET /llm              # 获取LLM配置
│   ├── PUT /llm              # 更新LLM配置
│   ├── GET /datasource       # 获取数据源配置
│   └── PUT /datasource       # 更新数据源配置
│
├── /screening                # 筛选模块
│   ├── POST /filter          # 条件筛选
│   └── GET /strategies       # 筛选策略
│
├── /paper                    # 模拟交易模块
│   ├── POST /trade           # 下单
│   ├── GET /positions        # 持仓查询
│   └── GET /history          # 交易历史
│
├── /reports                  # 报告模块
│   ├── GET /{id}/markdown    # Markdown导出
│   ├── GET /{id}/word        # Word导出
│   └── GET /{id}/pdf         # PDF导出
│
├── /sync                     # 数据同步模块
│   ├── POST /trigger         # 手动触发同步
│   └── GET /status           # 同步状态
│
└── /scheduler                # 调度模块
    ├── GET /jobs             # 任务列表
    ├── POST /jobs            # 创建任务
    └── DELETE /jobs/{id}     # 删除任务
```

#### 2.5.2 中间件管道

```
请求进入
  ↓
[CORS 中间件] → 跨域处理
  ↓
[速率限制中间件] → 请求频率控制
  ↓
[认证中间件] → JWT Token 验证
  ↓
[操作日志中间件] → 记录请求日志
  ↓
[路由分发] → 匹配路由处理函数
  ↓
[业务处理] → 执行业务逻辑
  ↓
[错误处理中间件] → 统一异常处理
  ↓
响应返回
```

#### 2.5.3 分析服务设计

```python
class AnalysisService:
    """分析服务 - 核心业务逻辑"""

    async def create_analysis(self, request: AnalysisRequest) -> AnalysisTask:
        """创建分析任务"""
        # 1. 验证股票代码有效性
        # 2. 创建任务记录（状态：pending）
        # 3. 加入分析队列
        # 4. 返回任务ID

    async def execute_analysis(self, task_id: str):
        """执行分析任务（后台）"""
        # 1. 更新任务状态（running）
        # 2. 初始化 TradingAgentsGraph
        # 3. 配置分析参数
        # 4. 执行 propagate（前向传播）
        # 5. 执行 reflect（反思学习）
        # 6. 处理信号生成决策
        # 7. 保存结果到数据库
        # 8. 更新任务状态（completed/failed）
        # 9. 推送实时通知

    async def get_analysis_result(self, task_id: str) -> AnalysisResult:
        """获取分析结果"""
```

#### 2.5.4 队列服务设计

```python
class QueueService:
    """分析任务队列服务"""

    def __init__(self):
        self.queue = asyncio.Queue()
        self.max_concurrent = 3  # 最大并发数

    async def enqueue(self, task: AnalysisTask):
        """入队"""

    async def process_queue(self):
        """消费队列（常驻协程）"""

    async def cancel_task(self, task_id: str):
        """取消任务"""
```

### 2.6 前端应用设计

#### 2.6.1 页面路由

| 路由 | 页面 | 功能 |
|------|------|------|
| `/login` | 登录页 | 用户认证 |
| `/` | 首页仪表板 | 概览信息 |
| `/analysis` | 分析页 | 发起和查看分析 |
| `/analysis/:id` | 分析详情 | 查看完整分析报告 |
| `/stocks` | 股票列表 | 股票搜索与浏览 |
| `/screening` | 股票筛选 | 条件筛选 |
| `/paper` | 模拟交易 | 模拟买卖 |
| `/reports` | 报告中心 | 历史报告管理 |
| `/sync` | 数据同步 | 数据同步管理 |
| `/config` | 配置中心 | 系统配置 |
| `/logs` | 日志查看 | 系统日志 |

#### 2.6.2 状态管理 (Pinia Stores)

```
Stores
├── useAuthStore        # 认证状态（Token、用户信息）
├── useAnalysisStore    # 分析状态（任务列表、当前分析）
├── useStockStore       # 股票状态（搜索结果、自选股）
├── useConfigStore      # 配置状态（LLM配置、系统设置）
└── useNotificationStore # 通知状态（实时消息）
```

---

## 3. 数据库设计

### 3.1 MongoDB 集合设计

#### 3.1.1 用户集合 (users)

```json
{
    "_id": "ObjectId",
    "username": "string",
    "email": "string",
    "password_hash": "string (bcrypt)",
    "role": "string (admin/user)",
    "is_active": "boolean",
    "created_at": "datetime",
    "updated_at": "datetime",
    "last_login": "datetime"
}
```

#### 3.1.2 分析任务集合 (analysis_tasks)

```json
{
    "_id": "ObjectId",
    "user_id": "ObjectId (ref: users)",
    "ticker": "string",
    "company_name": "string",
    "market_type": "string (A股/港股/美股)",
    "status": "string (pending/running/completed/failed)",
    "config": {
        "llm_provider": "string",
        "deep_think_model": "string",
        "quick_think_model": "string",
        "max_debate_rounds": "int",
        "max_risk_discuss_rounds": "int"
    },
    "result": {
        "market_report": "string",
        "fundamentals_report": "string",
        "news_report": "string",
        "sentiment_report": "string",
        "bull_report": "string",
        "bear_report": "string",
        "investment_plan": "string",
        "risk_assessment": "string",
        "final_decision": "string",
        "action": "string (买入/持有/卖出)",
        "confidence": "float (0-1)",
        "target_price": "float (可选)",
        "stop_loss": "float (可选)"
    },
    "created_at": "datetime",
    "started_at": "datetime",
    "completed_at": "datetime",
    "error_message": "string (可选)"
}
```

#### 3.1.3 股票基础数据集合 (stocks)

```json
{
    "_id": "ObjectId",
    "code": "string",
    "name": "string",
    "market": "string",
    "exchange": "string",
    "industry": "string",
    "sector": "string",
    "list_date": "string",
    "status": "string (正常/退市/停牌)",
    "updated_at": "datetime"
}
```

#### 3.1.4 配置集合 (configurations)

```json
{
    "_id": "ObjectId",
    "config_type": "string (llm/datasource/system)",
    "config_data": "object",
    "updated_by": "ObjectId",
    "updated_at": "datetime"
}
```

#### 3.1.5 操作日志集合 (operation_logs)

```json
{
    "_id": "ObjectId",
    "user_id": "ObjectId",
    "action": "string",
    "resource": "string",
    "method": "string (GET/POST/PUT/DELETE)",
    "path": "string",
    "status_code": "int",
    "ip_address": "string",
    "created_at": "datetime"
}
```

### 3.2 Redis 缓存设计

| Key 模式 | 类型 | TTL | 用途 |
|---------|------|-----|------|
| `market:{ticker}:{depth}` | Hash | 5min | 市场行情缓存 |
| `fundamentals:{ticker}` | Hash | 1day | 基本面数据缓存 |
| `news:{ticker}:{days}` | String | 30min | 新闻数据缓存 |
| `sentiment:{ticker}` | String | 1hour | 情绪数据缓存 |
| `session:{user_id}` | String | 24hour | 用户会话 |
| `rate_limit:{ip}` | Counter | 1min | 速率限制计数 |

---

## 4. 配置管理设计

### 4.1 配置层级

```
优先级（高 → 低）:
  ↓
环境变量 (.env)            # 敏感配置（API Key、密码）
  ↓
数据库配置 (MongoDB)       # 运行时可修改的配置
  ↓
默认配置 (default_config.py) # 代码中的默认值
```

### 4.2 核心配置项

```python
DEFAULT_CONFIG = {
    # LLM 配置
    "llm_provider": "openai",           # LLM 提供商
    "deep_think_llm": "o4-mini",        # 深度思考模型
    "quick_think_llm": "gpt-4o-mini",   # 快速思考模型

    # 分析流程配置
    "max_debate_rounds": 1,             # 辩论轮数
    "max_risk_discuss_rounds": 1,       # 风险讨论轮数
    "max_recur_limit": 100,             # 最大递归限制

    # 功能开关
    "online_tools": False,              # 在线工具
    "online_news": True,                # 在线新闻
    "realtime_data": False,             # 实时数据

    # 数据源配置
    "default_china_data_source": "akshare",  # 默认A股数据源
}
```

---

## 5. 异常处理设计

### 5.1 异常分类

| 异常类型 | 处理策略 | HTTP 状态码 |
|---------|---------|------------|
| 数据源不可用 | 自动降级到备选数据源 | 502 |
| LLM 调用失败 | 重试3次后返回错误 | 503 |
| 认证失败 | 返回未授权响应 | 401 |
| 参数验证失败 | 返回详细错误信息 | 422 |
| 股票代码无效 | 返回明确提示 | 400 |
| 内部错误 | 记录日志，返回通用错误 | 500 |
| 速率限制 | 返回限流提示 | 429 |

### 5.2 全局错误处理

```python
@app.exception_handler(Exception)
async def global_error_handler(request, exc):
    """全局异常处理中间件"""
    logger.error(f"未处理异常: {exc}", exc_info=True)
    return JSONResponse(
        status_code=500,
        content={"detail": "内部服务器错误", "error_id": generate_error_id()}
    )
```

---

## 6. 日志设计

### 6.1 日志级别

| 级别 | 用途 |
|------|------|
| DEBUG | 开发调试信息 |
| INFO | 正常业务流程记录 |
| WARNING | 数据源降级、缓存未命中等 |
| ERROR | 业务异常、API调用失败 |
| CRITICAL | 系统级故障 |

### 6.2 日志格式

```
[%(asctime)s] [%(levelname)s] [%(module)s:%(lineno)d] %(message)s
```

### 6.3 日志分类

- **应用日志**：业务逻辑执行记录
- **访问日志**：API请求/响应记录
- **分析日志**：智能体分析过程详情
- **数据日志**：数据源调用记录

---

## 7. 安全设计

### 7.1 认证流程

```
用户登录
  ↓
验证用户名/密码 (bcrypt 比对)
  ↓
生成 JWT Token (HS256, 含 user_id + role + exp)
  ↓
返回 Token 给前端
  ↓
前端请求时携带 Authorization: Bearer <token>
  ↓
后端中间件验证 Token 有效性
  ↓
注入用户上下文到请求
```

### 7.2 API 安全

- **速率限制**：基于 IP 的请求频率限制
- **输入验证**：Pydantic 模型自动校验
- **SQL注入防护**：MongoDB 查询参数化
- **XSS防护**：前端输入转义
- **CORS配置**：限制允许的跨域来源
